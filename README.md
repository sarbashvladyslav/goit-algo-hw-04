Перша ітерація списку з 10_000 елементів:

| Кількість циклів | sort() (сек)   | Insertion Sort (сек) | Merge Sort (сек) |
| ---------------- | -------------- | -------------------- | ---------------- |
|   1 цикл         | 0.0006901      | 1.5070559            | 0.0148382        |
|   10 циклів      | 0.0008652      | 0.0069452            | 0.1451680        |
|   100 циклів     | 0.0028429      | 0.0682693            | 1.4531089        |

Друга ітерація списку з 10_000 елементів:

| Кількість циклів | sort() (сек)   | Insertion Sort (сек) | Merge Sort (сек) |
| ---------------- | -------------- | -------------------- | ---------------- |
|   1 цикл         | 0.0007524      | 1.5050064            | 0.0144696        |
|   10 циклів      | 0.0009280      | 0.0069814            | 0.1393815        |
|   100 циклів     | 0.0030820      | 0.0688039            | 1.4045783        |

Як бачимо з цих таблиць, вбудований метод Timsort демонструє найвищу ефективність серед трьох алгоритмів сортування.
При 1 циклі на масиві з 10 000 елементів алгоритм «Сортування вставками» (Insertion Sort) має найбільший час виконання,
але вже на наступному кроці — при 10 циклах — час значно зменшується.
Найповільнішим із трьох алгоритмів виявився «Сортування злиттям» (Merge Sort).

Різниця у відсотках між алгоритмами:

|  Insertion Sort vs sort() |          |   Merge Sort vs sort()  |
|         |                 |          |         |               |
| Цикли   | Різниця (%)     |          | Цикли   | Різниця (%)   |
| ------- | ----------------|          | ------- | ------------- |
|   1     |   +199,813 %    |          |   1     |   +1 822 %    |
|   10    |   +652,062 %    |          |   10    |   +14 920 %   |
|   100   |   +2 133,155 %  |          |   100   |   +45 512 %   |

Різниця просто колосальна — від 200 % до понад 45 000 %,
що ще раз підкреслює ефективність вбудованих методів Python порівняно з реалізаціями «вручну».